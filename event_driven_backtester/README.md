# Event-Driven Backtesting Engine

A minimal yet powerful event-driven backtesting framework for running trading strategies against historical OHLCV (Open, High, Low, Close, Volume) data.

## üéØ Features

- **Event-Driven Architecture**: Mimics real-time trading with an event queue system
- **Multiple Strategy Support**: Includes Moving Average Crossover, RSI, and Buy & Hold strategies
- **Realistic Simulation**: Handles orders, fills, and portfolio tracking
- **Performance Metrics**: Calculates Sharpe ratio, maximum drawdown, and total returns
- **Extensible Design**: Easy to add custom strategies and execution handlers
- **Commission Modeling**: Realistic commission calculations based on Interactive Brokers fees

## üìã Requirements

```bash
pip install pandas numpy
```

## üöÄ Quick Start

### 1. Generate Sample Data

First, generate sample OHLCV data for testing:

```bash
cd event_driven_backtester
python generate_sample_data.py
```

This creates sample data files for AAPL, MSFT, and GOOG in the `data/` directory.

### 2. Run a Backtest

Run the example backtesting script:

```bash
python run_backtest.py
```

This will run backtests for all included strategies and display performance metrics.

### 3. Run a Specific Strategy

You can also run a specific strategy:

```python
from run_backtest import run_backtest

# Run Moving Average Crossover strategy
results = run_backtest('ma_cross')

# Run Buy and Hold strategy
results = run_backtest('buy_hold')

# Run RSI strategy
results = run_backtest('rsi')
```

## üìä Architecture

The backtesting engine follows an event-driven architecture with the following components:

### Core Components

1. **Event System** (`events.py`)
   - `MarketEvent`: New market data available
   - `SignalEvent`: Trading signal generated by strategy
   - `OrderEvent`: Order to be executed
   - `FillEvent`: Confirmation of executed order

2. **Data Handler** (`data_handler.py`)
   - Loads historical OHLCV data from CSV files
   - Provides bar-by-bar data feed
   - Supports multiple symbols

3. **Strategy** (`strategy.py`)
   - Abstract base class for trading strategies
   - Implements signal generation logic
   - Included strategies:
     - **Moving Average Crossover**: Trades based on SMA crossovers
     - **RSI Strategy**: Trades based on overbought/oversold conditions
     - **Buy and Hold**: Simple baseline strategy

4. **Portfolio** (`portfolio.py`)
   - Tracks positions and holdings
   - Manages cash and equity
   - Converts signals to orders
   - Calculates performance metrics

5. **Execution Handler** (`execution.py`)
   - Simulates order execution
   - Handles commission and slippage
   - Converts orders to fills

6. **Backtest Engine** (`backtest.py`)
   - Orchestrates the entire backtesting process
   - Manages the event loop
   - Outputs performance statistics

## üìà Data Format

The engine expects CSV files with the following format:

```csv
timestamp,open,high,low,close,volume
2020-01-01,100.00,105.00,99.00,103.50,1500000
2020-01-02,103.50,107.00,102.00,106.25,1800000
...
```

- **timestamp**: Date in YYYY-MM-DD format
- **open**: Opening price
- **high**: Highest price during the period
- **low**: Lowest price during the period
- **close**: Closing price
- **volume**: Trading volume

## üîß Creating Custom Strategies

To create a custom strategy, inherit from the `Strategy` base class:

```python
from strategy import Strategy
from events import SignalEvent

class MyCustomStrategy(Strategy):
    def __init__(self, bars, events, param1=10):
        self.bars = bars
        self.events = events
        self.param1 = param1
        self.symbol_list = bars.symbol_list
        
    def calculate_signals(self, event):
        if event.type == 'MARKET':
            for symbol in self.symbol_list:
                # Get historical data
                bars = self.bars.get_latest_bars(symbol, N=20)
                
                # Implement your strategy logic here
                # ...
                
                # Generate signal
                signal = SignalEvent(
                    symbol=symbol,
                    datetime=self.bars.get_latest_bar_datetime(symbol),
                    signal_type='LONG',  # or 'EXIT'
                    strength=1.0
                )
                self.events.put(signal)
```

## üìä Example Output

```
============================================================
Running Backtest with ma_cross strategy
============================================================
Symbol List: ['AAPL']
Initial Capital: $100,000.00
Start Date: 2020-01-01
Data Directory: ./data
============================================================
Creating DataHandler, Strategy, Portfolio and ExecutionHandler
Processing bar 1461...

============================================================
Backtest Complete!
============================================================
Signals: 8
Orders: 8
Fills: 8
============================================================

Performance Summary:
------------------------------------------------------------
Total Return                           15.23%
Sharpe Ratio                             1.45
Max Drawdown                             8.32%
Drawdown Duration                          45
============================================================

Results saved to: backtest_results_ma_cross.csv
```

## üéì Strategy Descriptions

### Moving Average Crossover
- **Short Window**: 50 days (default)
- **Long Window**: 200 days (default)
- **Logic**: Buy when short MA crosses above long MA, sell when it crosses below

### RSI Strategy
- **Period**: 14 days (default)
- **Oversold**: 30 (default)
- **Overbought**: 70 (default)
- **Logic**: Buy when RSI < oversold threshold, sell when RSI > overbought threshold

### Buy and Hold
- **Logic**: Buy on first bar and hold until the end

## üìù Performance Metrics

The engine calculates the following metrics:

- **Total Return**: Overall percentage return
- **Sharpe Ratio**: Risk-adjusted return (annualized)
- **Max Drawdown**: Largest peak-to-trough decline
- **Drawdown Duration**: Longest drawdown period in days

## üîç Advanced Usage

### Custom Data Handler

You can create a custom data handler for different data sources:

```python
from data_handler import DataHandler

class MyDataHandler(DataHandler):
    def __init__(self, events, data_source):
        # Initialize your data source
        pass
        
    def get_latest_bar(self, symbol):
        # Implement data retrieval
        pass
    
    # Implement other required methods...
```

### Realistic Execution Handler

Use `RealisticExecutionHandler` for slippage modeling:

```python
from execution import RealisticExecutionHandler

# In your backtest setup:
execution_handler_cls=RealisticExecutionHandler
```

## ü§ù Contributing

Contributions are welcome! To contribute:

1. Fork the repository
2. Create a feature branch
3. Add your strategy or enhancement
4. Submit a pull request

## üìÑ License

This project is part of Hacktoberfest 2025 contributions.

## üêõ Troubleshooting

### "Sample data not found" Error
Run `python generate_sample_data.py` to create sample data files.

### Import Errors
Make sure you're running scripts from within the `event_driven_backtester` directory or adjust your Python path accordingly.

### Memory Issues
For large datasets, consider:
- Processing data in chunks
- Using a database instead of in-memory storage
- Reducing the date range for backtesting

## üìö Resources

- [Event-Driven Backtesting Explained](https://www.quantstart.com/articles/Event-Driven-Backtesting-with-Python-Part-I/)
- [Algorithmic Trading Strategies](https://www.quantstart.com/articles/Algorithmic-Trading-Strategies/)
- [Portfolio Optimization](https://www.quantstart.com/articles/Portfolio-Optimisation-with-Python/)

## üéØ Future Enhancements

- [ ] Add support for multiple timeframes
- [ ] Implement walk-forward optimization
- [ ] Add Monte Carlo simulation
- [ ] Support for options and futures
- [ ] Real-time paper trading mode
- [ ] Integration with live data feeds
- [ ] Web-based dashboard for results visualization
- [ ] Database backend for large datasets

---

**Happy Backtesting! üìà**
