"""
Strategy classes for generating trading signals.
"""

from abc import ABCMeta, abstractmethod
import numpy as np
from .events import SignalEvent


class Strategy(metaclass=ABCMeta):
    """
    Abstract base class for all trading strategies.
    
    The goal of a (derived) Strategy object is to generate Signal
    objects for particular symbols based on the inputs of Bars
    (OHLCV) generated by a DataHandler object.
    """

    @abstractmethod
    def calculate_signals(self, event):
        """
        Provides the mechanism to calculate the list of signals.
        """
        raise NotImplementedError("Should implement calculate_signals()")


class BuyAndHoldStrategy(Strategy):
    """
    A simple buy and hold strategy that buys on the first bar and holds.
    """
    
    def __init__(self, bars, events):
        """
        Initialize the buy and hold strategy.
        
        Parameters:
        -----------
        bars : DataHandler
            The DataHandler object that provides bar information
        events : Queue
            The Event Queue object
        """
        self.bars = bars
        self.symbol_list = self.bars.symbol_list
        self.events = events
        
        # For buy and hold we are always invested for each symbol
        self.bought = self._calculate_initial_bought()

    def _calculate_initial_bought(self):
        """
        Initialize the bought dictionary for all symbols to False.
        """
        bought = {}
        for s in self.symbol_list:
            bought[s] = False
        return bought

    def calculate_signals(self, event):
        """
        For a buy and hold strategy, we simply buy on the first signal.
        
        Parameters:
        -----------
        event : MarketEvent
            A MarketEvent object
        """
        if event.type == 'MARKET':
            for symbol in self.symbol_list:
                bars = self.bars.get_latest_bars(symbol, N=1)
                if bars is not None and len(bars) > 0:
                    if not self.bought[symbol]:
                        # (Symbol, Datetime, Type = LONG, Strength)
                        signal = SignalEvent(
                            symbol, 
                            bars[0][0], 
                            'LONG', 
                            1.0
                        )
                        self.events.put(signal)
                        self.bought[symbol] = True


class MovingAverageCrossStrategy(Strategy):
    """
    Simple Moving Average Crossover strategy.
    Generates signals based on a short-period SMA crossing a long-period SMA.
    """

    def __init__(self, bars, events, short_window=50, long_window=200):
        """
        Initialize the moving average cross strategy.
        
        Parameters:
        -----------
        bars : DataHandler
            The DataHandler object that provides bar information
        events : Queue
            The Event Queue object
        short_window : int
            The short moving average lookback period
        long_window : int
            The long moving average lookback period
        """
        self.bars = bars
        self.symbol_list = self.bars.symbol_list
        self.events = events
        self.short_window = short_window
        self.long_window = long_window

        # Tracking whether we are currently long the market
        self.bought = self._calculate_initial_bought()

    def _calculate_initial_bought(self):
        """
        Initialize the bought dictionary for all symbols to 'OUT'.
        """
        bought = {}
        for s in self.symbol_list:
            bought[s] = 'OUT'
        return bought

    def calculate_signals(self, event):
        """
        Calculate the signals based on moving average crossover.
        
        Parameters:
        -----------
        event : MarketEvent
            A MarketEvent object
        """
        if event.type == 'MARKET':
            for s in self.symbol_list:
                bars = self.bars.get_latest_bars_values(
                    s, "close", N=self.long_window
                )
                
                if bars is not None and len(bars) >= self.long_window:
                    # Calculate the simple moving averages
                    short_sma = np.mean(bars[-self.short_window:])
                    long_sma = np.mean(bars[-self.long_window:])
                    
                    # Get current timestamp
                    dt = self.bars.get_latest_bar_datetime(s)
                    
                    # Generate signals
                    if short_sma > long_sma and self.bought[s] == 'OUT':
                        # Long signal
                        signal = SignalEvent(s, dt, 'LONG', 1.0)
                        self.events.put(signal)
                        self.bought[s] = 'LONG'
                        
                    elif short_sma < long_sma and self.bought[s] == 'LONG':
                        # Short (exit) signal
                        signal = SignalEvent(s, dt, 'EXIT', 1.0)
                        self.events.put(signal)
                        self.bought[s] = 'OUT'


class RSIStrategy(Strategy):
    """
    Relative Strength Index (RSI) strategy.
    Buys when RSI is oversold (<30) and sells when overbought (>70).
    """

    def __init__(self, bars, events, period=14, oversold=30, overbought=70):
        """
        Initialize the RSI strategy.
        
        Parameters:
        -----------
        bars : DataHandler
            The DataHandler object that provides bar information
        events : Queue
            The Event Queue object
        period : int
            The RSI calculation period
        oversold : float
            The oversold threshold (typically 30)
        overbought : float
            The overbought threshold (typically 70)
        """
        self.bars = bars
        self.symbol_list = self.bars.symbol_list
        self.events = events
        self.period = period
        self.oversold = oversold
        self.overbought = overbought
        
        self.bought = self._calculate_initial_bought()

    def _calculate_initial_bought(self):
        """
        Initialize the bought dictionary for all symbols to 'OUT'.
        """
        bought = {}
        for s in self.symbol_list:
            bought[s] = 'OUT'
        return bought

    def _calculate_rsi(self, prices):
        """
        Calculate the RSI indicator.
        
        Parameters:
        -----------
        prices : list
            List of closing prices
            
        Returns:
        --------
        float : The RSI value
        """
        deltas = np.diff(prices)
        seed = deltas[:self.period+1]
        up = seed[seed >= 0].sum() / self.period
        down = -seed[seed < 0].sum() / self.period
        rs = up / down if down != 0 else 0
        rsi = 100.0 - (100.0 / (1.0 + rs))
        
        # Calculate RSI for remaining prices
        for delta in deltas[self.period+1:]:
            if delta > 0:
                upval = delta
                downval = 0.0
            else:
                upval = 0.0
                downval = -delta
                
            up = (up * (self.period - 1) + upval) / self.period
            down = (down * (self.period - 1) + downval) / self.period
            rs = up / down if down != 0 else 0
            rsi = 100.0 - (100.0 / (1.0 + rs))
            
        return rsi

    def calculate_signals(self, event):
        """
        Calculate the signals based on RSI indicator.
        
        Parameters:
        -----------
        event : MarketEvent
            A MarketEvent object
        """
        if event.type == 'MARKET':
            for s in self.symbol_list:
                bars = self.bars.get_latest_bars_values(
                    s, "close", N=self.period + 50
                )
                
                if bars is not None and len(bars) >= self.period + 2:
                    # Calculate RSI
                    rsi = self._calculate_rsi(bars)
                    
                    # Get current timestamp
                    dt = self.bars.get_latest_bar_datetime(s)
                    
                    # Generate signals
                    if rsi < self.oversold and self.bought[s] == 'OUT':
                        # Oversold - Buy signal
                        signal = SignalEvent(s, dt, 'LONG', 1.0)
                        self.events.put(signal)
                        self.bought[s] = 'LONG'
                        
                    elif rsi > self.overbought and self.bought[s] == 'LONG':
                        # Overbought - Sell signal
                        signal = SignalEvent(s, dt, 'EXIT', 1.0)
                        self.events.put(signal)
                        self.bought[s] = 'OUT'
