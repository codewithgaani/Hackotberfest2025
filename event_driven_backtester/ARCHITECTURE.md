# Event-Driven Backtesting Architecture

## Overview

This document provides a detailed explanation of the event-driven backtesting architecture and how the components interact.

## Event-Driven Design

The backtesting engine uses an **event-driven architecture** that closely mimics live trading systems. This approach offers several advantages:

1. **Realistic Simulation**: Events are processed sequentially, just like in live trading
2. **Modular Design**: Each component is independent and can be easily modified
3. **Easy Transition to Live Trading**: The same code can be adapted for live trading with minimal changes
4. **Clear Separation of Concerns**: Each component has a specific responsibility

## System Components

### 1. Event System

The event system is the backbone of the architecture. All components communicate through events.

#### Event Types

```
MarketEvent
    ↓
SignalEvent
    ↓
OrderEvent
    ↓
FillEvent
```

**Event Flow:**

1. **MarketEvent**: Triggered when new market data arrives
   - Generated by: `DataHandler`
   - Consumed by: `Strategy`

2. **SignalEvent**: Trading signal from strategy
   - Generated by: `Strategy`
   - Consumed by: `Portfolio`
   - Contains: Symbol, timestamp, direction (LONG/EXIT), strength

3. **OrderEvent**: Order to be executed
   - Generated by: `Portfolio`
   - Consumed by: `ExecutionHandler`
   - Contains: Symbol, order type, quantity, direction

4. **FillEvent**: Confirmation of executed order
   - Generated by: `ExecutionHandler`
   - Consumed by: `Portfolio`
   - Contains: Execution details, cost, commission

### 2. Data Handler

**Responsibility**: Provide historical market data in a bar-by-bar manner

**Key Methods:**
- `update_bars()`: Advance to the next bar
- `get_latest_bar()`: Get the most recent bar
- `get_latest_bars(N)`: Get the last N bars
- `get_latest_bar_value(val_type)`: Get specific OHLCV value

**Design Pattern**: Iterator pattern with generator

### 3. Strategy

**Responsibility**: Generate trading signals based on market data

**Base Class**: `Strategy` (abstract)

**Implemented Strategies:**

1. **Buy and Hold**
   - Simplest strategy
   - Buy on first bar, hold forever
   - Used as baseline

2. **Moving Average Crossover**
   - Technical indicator based
   - Two SMA periods (short and long)
   - Buy when short > long, sell when short < long

3. **RSI Strategy**
   - Momentum indicator based
   - Uses Relative Strength Index
   - Buy when oversold, sell when overbought

**Key Method:**
- `calculate_signals(event)`: Process market events and generate signals

### 4. Portfolio

**Responsibility**: Manage positions, track equity, generate orders

**Key Features:**
- Position tracking per symbol
- Holdings (cash + positions value)
- Performance calculation
- Risk management (in advanced implementations)

**Key Methods:**
- `update_signal(event)`: Convert signal to order
- `update_fill(event)`: Update positions after fill
- `update_timeindex(event)`: Update portfolio snapshot
- `create_equity_curve_dataframe()`: Generate results

**Data Structures:**
- `current_positions`: Current position sizes
- `current_holdings`: Current cash and equity
- `all_positions`: Historical position snapshots
- `all_holdings`: Historical holdings snapshots

### 5. Execution Handler

**Responsibility**: Execute orders and generate fills

**Types:**

1. **SimulatedExecutionHandler**
   - Instant execution at market price
   - No slippage or latency
   - Perfect for initial testing

2. **RealisticExecutionHandler**
   - Includes slippage modeling
   - More realistic commission structure
   - Better for final validation

**Key Method:**
- `execute_order(event)`: Convert order to fill

### 6. Backtest Engine

**Responsibility**: Orchestrate the entire backtesting process

**Main Loop:**

```python
while data_available:
    # 1. Get new market data
    data_handler.update_bars()
    
    # 2. Process all events in queue
    while events_in_queue:
        event = get_event()
        
        if event is MarketEvent:
            strategy.calculate_signals()
            portfolio.update_timeindex()
            
        elif event is SignalEvent:
            portfolio.update_signal()
            
        elif event is OrderEvent:
            execution.execute_order()
            
        elif event is FillEvent:
            portfolio.update_fill()
```

## Data Flow Diagram

```
┌─────────────────┐
│   CSV Files     │
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│  Data Handler   │──────┐
└────────┬────────┘      │
         │               │
         ▼               │
    MarketEvent          │
         │               │
         ▼               │
┌─────────────────┐      │
│    Strategy     │◄─────┘
└────────┬────────┘
         │
         ▼
    SignalEvent
         │
         ▼
┌─────────────────┐
│   Portfolio     │
└────────┬────────┘
         │
         ▼
    OrderEvent
         │
         ▼
┌─────────────────┐
│   Execution     │
└────────┬────────┘
         │
         ▼
    FillEvent
         │
         ▼
┌─────────────────┐
│   Portfolio     │
│  (Update Fill)  │
└─────────────────┘
```

## Extending the System

### Adding a New Strategy

1. Create a new class inheriting from `Strategy`
2. Implement `calculate_signals(event)` method
3. Use `self.bars` to access market data
4. Put `SignalEvent` objects on the event queue

Example:

```python
class BollingerBandsStrategy(Strategy):
    def __init__(self, bars, events, period=20, std_dev=2):
        self.bars = bars
        self.events = events
        self.period = period
        self.std_dev = std_dev
        
    def calculate_signals(self, event):
        if event.type == 'MARKET':
            # Get data
            closes = self.bars.get_latest_bars_values('AAPL', 'close', N=self.period)
            
            # Calculate bands
            sma = np.mean(closes)
            std = np.std(closes)
            upper = sma + (self.std_dev * std)
            lower = sma - (self.std_dev * std)
            
            current = closes[-1]
            
            # Generate signals
            if current < lower:
                signal = SignalEvent('AAPL', datetime.now(), 'LONG', 1.0)
                self.events.put(signal)
            elif current > upper:
                signal = SignalEvent('AAPL', datetime.now(), 'EXIT', 1.0)
                self.events.put(signal)
```

### Adding Custom Data Sources

1. Inherit from `DataHandler`
2. Implement required abstract methods
3. Use your custom data source (database, API, etc.)

### Improving the Portfolio

Enhancements to consider:
- Position sizing based on volatility
- Risk management (stop losses)
- Multiple position support
- Fractional shares
- Leverage modeling

## Performance Metrics

### Calculated Metrics

1. **Total Return**
   - Formula: `(Final Equity / Initial Capital) - 1`
   - Measures overall profitability

2. **Sharpe Ratio**
   - Formula: `sqrt(252) * mean(returns) / std(returns)`
   - Measures risk-adjusted returns
   - Higher is better (>1 is good, >2 is excellent)

3. **Maximum Drawdown**
   - Largest peak-to-trough decline
   - Measures worst-case scenario
   - Lower is better

4. **Drawdown Duration**
   - Longest period in drawdown
   - Measures recovery time
   - Shorter is better

## Best Practices

### 1. Data Quality
- Ensure OHLCV data is clean
- Check for missing values
- Validate timestamp ordering
- Adjust for splits and dividends

### 2. Strategy Development
- Start simple, add complexity gradually
- Test on out-of-sample data
- Avoid overfitting (too many parameters)
- Consider transaction costs

### 3. Performance Analysis
- Compare against buy-and-hold
- Check multiple time periods
- Analyze drawdown periods
- Validate with different symbols

### 4. Risk Management
- Never risk too much per trade
- Use stop losses
- Diversify across symbols
- Monitor correlation

## Common Pitfalls

1. **Look-Ahead Bias**
   - Using future information in decisions
   - Solution: Ensure all data is "as of" the current timestamp

2. **Survivorship Bias**
   - Only testing on currently listed stocks
   - Solution: Include delisted companies in data

3. **Overfitting**
   - Optimizing too much on historical data
   - Solution: Use train/test split, walk-forward analysis

4. **Transaction Costs**
   - Ignoring commissions and slippage
   - Solution: Model realistic costs

5. **Data Snooping**
   - Testing multiple strategies on same data
   - Solution: Reserve holdout data for validation

## Further Reading

- "Algorithmic Trading" by Ernie Chan
- "Quantitative Trading" by Ernie Chan
- "Advances in Financial Machine Learning" by Marcos López de Prado
- QuantStart.com articles on event-driven backtesting

## License

MIT License - Feel free to use and modify
